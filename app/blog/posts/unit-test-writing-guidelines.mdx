---
title: '単体テストコードのお作法'
publishedAt: '2025-10-20'
summary: ''
tags: ["Testing"]
---

こんにちは! @silverbirder です。
今回、私が個人的に心掛けている、単体テストコードを書く上でのお作法について共有します。
読者の皆さんが、より良いテストコードを書く一助になれば幸いです。

## 前提

- 技術セットは、TypeScriptとVitestを想定していますが、技術セットに依存しない考え方です。
- ここではプロダクション側のコードを「プロダクションコード」、テスト側を「テストコード」と呼びます。

### 単体テスト

単体テストとは、ある関数やクラス、コンポーネントなどの最小単位のコードが、仕様通りに動作するかを検証するテストです。
単体テストでは、中の実装を意識したブラックボックステストを行います。

## テストコードを書く目的

私が思うテストコードを書く目的は、以下の3点です。

- 開発効率の向上（キーストロークの削減）
- 機能品質の維持
- 仕様の明確化

詳しくは、私が以前に書いた記事をご覧ください。

- [Webフロントエンドにおける網羅的テストパターンガイド - zenn](https://zenn.dev/silverbirder/articles/c3de04c9e6dd58)

要するに、テストコードを書くことで、手動での動作確認を減らし、バグの混入を防ぎ、仕様を明確にすることができます。

## テストコードは読みやすさを意識する

プロダクションコードではユーザーへ提供するため、パフォーマンスやユーザビリティなどさまざまな観点を考慮してコードを書きます。
そのためには、設計を洗練させたり、抽象化したり、共通化したりといった工夫が必要です。

一方でテストコードは、ユーザーへ提供するものではなく、開発者のためのコードです。
開発者は、実装した機能が仕様通りの振る舞いをする責任があります。
そのためには、手動で動作確認することもあれば、テストコードを書いて自動で検証することもあります。
（ユーザーのためである）プロダクションコードのような最適化は必要ではなく、テストコードは仕様を素直に表現したドキュメントとして扱われるべきです。

結果、テストコードは「読みやすい」ことを意識します。
では、具体的にどのように読みやすくするか、以下で説明します。

## お題となるコード

今回は、ECサイトのカートの中にある商品の合計金額を計算する関数 `calculateCartTotal` のテストコードを例にします。
クーポンの割引と消費税を計算した上で、合計金額を返す関数です。かなり簡略化しています。

```ts
type CartItem = {
  id: string;
  name: string;
  price: number;
  quantity: number;
};

type Coupon = {
  type: "percent";
  value: number;
  minAmount?: number;
  expiresAt?: Date;
};

// 消費税（軽減税率）
const TAX_RATE = 0.8;

/** カート全体の合計 */
export const calculateCartTotal = (
  items: CartItem[],
  coupon?: Coupon
): number => {
  // 小計を計算
  const subtotal = calculateSubtotal(items);
  let discountedSubtotal = subtotal;

  // クーポンが存在し、適用可能な場合のみ適用
  if (coupon && isCouponApplicable(subtotal, coupon)) {
    discountedSubtotal = applyCoupon(subtotal, coupon);
  }

  // 税込み価格を計算して返す
  return calculateTotalWithTax(discountedSubtotal);
};

/** 小計を計算 */
const calculateSubtotal = (items: CartItem[]): number =>
  items.reduce((sum, item) => sum + item.price * item.quantity, 0);

/** クーポンが適用可能かを判定する */
const isCouponApplicable = (subtotal: number, coupon: Coupon): boolean => {
  const now = new Date();

  if (coupon.expiresAt && coupon.expiresAt < now) return false;
  if (coupon.minAmount && subtotal < coupon.minAmount) return false;

  return true;
};

/** クーポンを適用 */
const applyCoupon = (subtotal: number, coupon?: Coupon): number => {
  if (!coupon) return subtotal;
  return subtotal * (1 - coupon.value / 100);
};

/** 税込み価格を計算 */
const calculateTotalWithTax = (subtotal: number): number =>
  Math.round(subtotal * (1 + TAX_RATE));
```

※ 普段は、JSXのテストを書いていますが、今回はロジックのテストコードにします。フロントエンドに依存しないようにしたいからです。

## お作法

### 共通: モックデータの生成

テストコードでは、テスト対象の関数やクラスを呼び出すために必要なデータを用意します。
今回のお題だと、

```ts
const generateItem = (override: Partial<CartItem> = {}): CartItem => ({
  id: "A",
  name: "Sample Product",
  price: 1000,
  quantity: 1,
  ...override,
});

const generateCoupon = (override: Partial<Coupon> = {}): Coupon => ({
  type: "percent",
  value: 10,
  ...override,
});
```

また、消費税の固定データを変数として用意しておきます。

```ts
const TAX_RATE = 0.8;
```

### Arrange-Act-Assert (AAA) パターンを守る

テストコードは、おおまかに以下の3つの流れがあると思います。

1. 前提条件の準備 (Arrange)
2. 目的のアクションを実行 (Act)
3. 期待値を検証 (Assert)

1は、テスト対象の関数やクラス、コンポーネントを呼び出すために必要なデータやモックなどを用意します。
2は、テスト対象に対して、期待値を確認するためのアクションを実行します。
3は、アクションの結果が期待値通りであることを検証します。

この流れは、1つのテストケースで1つだけにします。
逆に、Assert で目的の検証後に、次の Act → Assert をしてしまうと、
テストケースの範囲が広がってしまいます。
テストケースが広がると、テストの目的が増え読む範囲が広がります。

以下は、AAAパターンを守った例です。

```ts
it("should calculate total with tax when no coupon", () => {
  // Arrange
  const items = [
    generateItem({ price: 2000, quantity: 2 }),
    generateItem({ price: 5000 }),
  ];

  const subtotal = 2000 * 2 + 5000;
  const expectedTotal = subtotal * (1 + TAX_RATE);

  // Act
  const total = calculateCartTotal(items);

  // Assert
  expect(total).toBe(expectedTotal);
});
```

逆に、AAAパターンを崩した例です。

```ts
it("should calculate total with tax when coupon is applied", () => {
  // Arrange
  const items = [
    generateItem({ price: 2000, quantity: 2 }),
    generateItem({ price: 5000 }),
  ];
  const coupon = generateCoupon({ value: 10 });

  const subtotal = 2000 * 2 + 5000;
  const discountedSubtotal = subtotal * (1 - coupon.value / 100);
  const expectedTotal = discountedSubtotal * (1 + TAX_RATE);

  // Act
  const total = calculateCartTotal(items, coupon);

  // Assert
  expect(total).toBe(expectedTotal);

  // Act (NG)
  const totalWithoutCoupon = calculateCartTotal(items);

  // Assert (NG)
  expect(totalWithoutCoupon).toBe(subtotal * (1 + TAX_RATE));
});
```

### 愚直に書く

forやifといったロジックは、読む負荷が上がります。
for、ifは効率よく書けるのですが、読む際にロジックを追いかけなければいけません。
テストコードでは、そういったロジックを避けて、愚直に書きます。

```ts
// NG
const items = [];
for (let i = 0; i < 3; i++) {
  items.push(generateItem({ price: 1000 * (i + 1), quantity: i + 1 }));
}
```

```ts
// OK
const items = [
  generateItem({ price: 1000, quantity: 1 }),
  generateItem({ price: 2000, quantity: 2 }),
  generateItem({ price: 3000, quantity: 3 }),
];
```

また、期待値となる値を計算するために、プロダクトコードのロジックを複製するのは避けるべきです。
プロダクトコードに誤りがあったとしても、テストコードも同様であった場合、エラーとならないからです。

```ts
// NG
const expectedTotal = items.reduce((sum, item) => sum + item.price * item.quantity, 0) * (1 + TAX_RATE);
```

```ts
// OK
const expectedTotal = 14000 * (1 + TAX_RATE);
```


### 自然言語を意識する

よくテストケースの説明文が不自然だったり、曖昧な表現になったりしていることがあります。

```ts
// NG
it('should work correctly', () => {
  // ...
})

// OK
it('should calculate total with tax when no coupon', () => {
  // ...
})

// より具体的なテストケースも良い
it('should calculated total is 14000 when items are ...', () => {
  // ...
})
```

テストケースは、実際のテストコードを読まなくても、テストケースの文章だけで何をテストしているのか理解できることが理想です。
そのため、テストケースの文章は具体的に、かつ曖昧な表現を避けます。

```ts
// NG
it('should display correctly', () => {
  // ...
})

// OK
it('should display total amount with tax included', () => {
  // ...
})
```

私の場合、`it should ... when ...` の形にすることが多いです。

また、テストライブラリのマッチャーも、自然言語で前から読めるものを選びます。

```ts
// NG
// Arrange
const list = ['A', 'B', 'C'];

// Assert
expect(list.includes('A')).toBe(true)
```

```ts
// OK
// Arrange
const list = ['A', 'B', 'C'];

// Assert
expect(list).toContain('A')
```

また、否定系で書くよりも肯定系で書く方が読みやすいです。

```ts
// NG
// Arrange
const isDisabled = false;

// Assert
expect(isDisabled).not.toBeTruthy();
```

```ts
// OK
// Arrange
const isEnabled = true;

// Assert
expect(isEnabled).toBeFalsy();
```

### テストケースの中で完結する

テストコードを書いていると、テストケースそれぞれで共通した処理が出てきます。
そのときに、テストケース外に共通処理を実装し、テストケース内でそれらを呼び出すことがあります。
処理が共通されるのは良いのですが、テストケースを読んでいる最中に上下にスクロールしないと理解できなくなってしまいます。
1つのテストケース内で完結するようにします。

```ts
// NG
const generateItems = () => [
  generateItem({ price: 2000, quantity: 2 }),
  generateItem({ price: 5000 }),
];

it("should calculate total with tax when no coupon", () => {
  const items = generateItems(); // NG

  const subtotal = 2000 * 2 + 5000;
  const expectedTotal = subtotal * (1 + TAX_RATE);

  const total = calculateCartTotal(items);

  expect(total).toBe(expectedTotal);
});
```

```ts
// OK
const generateItem = (override: Partial<CartItem> = {}): CartItem => ({
  id: "A",
  name: "Sample Product",
  price: 1000,
  quantity: 1,
  ...override,
});

it("should calculate total with tax when no coupon", () => {
  // Arrange
  const items = [
    generateItem({ price: 2000, quantity: 2 }),
    generateItem({ price: 5000 }),
  ];

  const subtotal = 2000 * 2 + 5000;
  const expectedTotal = subtotal * (1 + TAX_RATE);

  // Act
  const total = calculateCartTotal(items);

  // Assert
  expect(total).toBe(expectedTotal);
});
```

どちらも、処理を共通化しているのは同じなのですが、前者の場合はモックデータの中身を確認するために `generateItems` の中身を追いかける必要があります。
後者の場合は、 `generateItem` の中身は知らなくても、`generateItem({ price: 2000, quantity: 2 })` のように、テストで必要なpriceとquantityを直接指定しているため、その計算が明示的になります。
私は、後者のようなテストケース内だけで テスト内容が理解しやすい形が好みです。
共通化は処理の効率が上がるのですが、テストケース内で定義変数に参照してしまうと、読む負荷が上がります。そうならないような配慮のある共通化を心がけます。

### コンテキストの深さを抑える

テストコードを書いていると、同じ文脈のテストケースをグルーピングしたくなることがあります。
その際に、以下のような入れ子構造を作ることがあります。

```ts
describe("calculateCartTotal", () => {
  describe("when coupon is applied", () => {
    describe("and coupon is valid", () => {
      it("should calculate total with tax after discount", () => {
        // ...
      });
    });

    describe("and coupon is expired", () => {
      it("should calculate total with tax without discount", () => {
        // ...
      });
    });
  });
});
```

入れ子構造は、コンテキストが深くなり読むレベルが上がります。
例えば、上記の例だと `should calculate total with tax after discount` を読むときに、3階層分のコンテキストを意識しなければいけません。
そのため、入れ子構造は2階層までに抑え、できる限りフラットにしたいです。

```ts
describe("calculateCartTotal", () => {
  it("should calculate total with tax after discount when coupon is valid", () => {
    // ...
  });

  it("should calculate total with tax without discount when coupon is expired", () => {
    // ...
  });
});
```

### 未実装テストとの付き合い方

プロダクトコードを実装していると、あとで実装する予定の機能が出てくることがあります。
その未実装には、例えば以下のようなプロダクトコードの例があります。

```ts
// 将来対応予定
const applyCoupon = (subtotal: number, coupon?: Coupon): number => {
  // TODO: Implement coupon application logic
  return subtotal;
};
```

こうした場合に、未実装のテストケースを用意しておくと良いです。

```ts
it("should apply coupon when coupon is valid", () => {
  const subtotal = 1000;
  const coupon = { code: "VALID_COUPON", value: 10 };
  const expectedTotal = 1000; // NOTE: 未実装のため、現状は割引されない

  const total = applyCoupon(subtotal, coupon);

  expect(total).toBe(expectedTotal);
});
```

こうすることで、未実装の機能を実装した際に、テストケースが失敗するため、テストケースを書くのを忘れにくくなります。
ただ、上記のテストコードに違和感があるかもしれません。まだ未実装である意図が伝わりにくいかもしれません。
そこで、テストライブラリによっては、失敗することを期待するテストを書くことができます。
vitest の場合は、it.fails を使います。

```ts
it.fails("should apply coupon when coupon is valid", () => {
  const subtotal = 1000;
  const coupon = { code: "VALID_COUPON", value: 10 };
  const expectedTotal = 900;

  const total = applyCoupon(subtotal, coupon);

  expect(total).toBe(expectedTotal);
});
```

もしくは、テストが実行されない `it.skip` や `it.todo` を使う方法もあります。
これは、テストケースの中身は実装せずに、どういうテストを書くかだけを残しておく方法です。

```ts
it.todo("should apply coupon when coupon is valid");
```

これらの未実装プロダクトコードをフィーチャー開発終了後には全て実装していることを確認する方法が欲しくなる時があります。
その場合は、テストケースにタグを付与して、`--testNamePattern` でフィルタリングする方法があります。

```ts
it.todo("should apply coupon when coupon is valid @coupon");
```

テスト実行時は、以下のようにフィルタリングします。

```bash
vitest --testNamePattern="@coupon"
```

あとは、上記のテスト結果の出力に、todo や fails のテストケースが残っていないことを確認します。

### テストの並び順を意識する

テストコードの並び順に意味を与えたくないのですが、
個人的には、『正常系 → 準正常系 → 異常系』の順に並べることが多いです。
なぜなら、最初に Happy Path を通すことで、後続のケースが「何を守るのか」の意図を伝えやすいからです。

例えば、以下のような順番です。

```ts
// 正常系
it("should calculate total with tax when no coupon", () => {
  // ...
});
it("should calculate total with tax when coupon is applied", () => {
  // ...
});
// 準正常系
it("should calculate total with tax without discount when coupon is expired", () => {
  // ...
});
// 異常系
it('should throw error when coupon type is unknown', () => {
  // ...
});
```

### アサートの粒度

テストコードでは、必ず検証を行います。
検証対象が、シンプルな値であれば良いのですが、データ量が多いテキストやオブジェクトの場合、検証を怠ってしまうことがあります。
アバウトに確認してしまうと、もしプロダクトコードにミスがあっても、テストコードでは成功してしまう可能性があるからです。
関数の実行回数や引数も、可能な限り丁寧に検証します。
オブジェクトも、可能なら全部で良いのですが、検査対象が一部なら一部テストをしましょう。

### 網羅的なテスト

テストコードでは、入力するパラメータのバリエーションによって期待する出力が変わる場合があります。
境界値や同値分割のテストを行う際は、パラメタライズドテストを使うと良いでしょう。
また、ON/OFF のような 2択状態のテストは、片方を基本として、もう一方だけテストでも良いのですが、その議論でコストがかかるぐらいなら、どちらもテストしたら良いです。

例えば、クーポン適用の有無の関数 `isCouponApplicable` の場合、以下のようにテストケースを分けます。

```ts
it.each`
  subtotal | minAmount    | expected
  ${1000}  | ${undefined} | ${true}
  ${1000}  | ${1001}      | ${true}
  ${1000}  | ${1000}      | ${true}
  ${1000}  | ${999}       | ${false}
`("should return $expected when subtotal=$subtotal and minAmount=$minAmount", ({ subtotal, minAmount, expected }) => {
  // Arrange
  const coupon = { type: "percent", value: 10, minAmount };

  // Act
  const result = isCouponApplicable(subtotal, coupon);

  // Assert
  expect(result).toBe(expected);
});
```

### 状態を持つテスト

実装によっては、状態を持つオブジェクトがテスト対象になることがあります。
そういったオブジェクトの場合のテストで、シーケンシャルに状態が変化するものがあった場合、1つのテストケースでまとめてしまうと、途中で失敗した場合に後続の検証が走らなくなります。
状態を持つオブジェクトのテストでは、状態ごとにテストケースを分けることを意識します。

例えば、以下のような簡易のカートクラスを考えます。

```ts
export enum CartState {
  Empty = "Empty",
  Active = "Active",
  CheckedOut = "CheckedOut",
}

export class Cart {
  private total = 0;
  private state = CartState.Empty;

  add(price: number) {
    if (this.state === CartState.CheckedOut) throw new Error("Already checked out");
    this.total += price;
    this.state = CartState.Active;
  }

  checkout() {
    if (this.state !== CartState.Active) throw new Error("Cannot checkout");
    this.total = 0;
    this.state = CartState.CheckedOut;
  }

  getState() {
    return this.state;
  }

  getTotal() {
    return this.total;
  }
}
```

このカートクラスのテストコードを書く際に、状態の検証する際 に、状態ごとにテストケースを分けます。

```ts
// NG
it("should be Empty state when initialized, Active state after adding an item, and CheckedOut state after checkout", () => {
  // Act
  const cart = new Cart();

  // Assert
  expect(cart.getState()).toBe(CartState.Empty); 

  // Act
  cart.add(1000);

  // Assert
  expect(cart.getState()).toBe(CartState.Active);

  // Act
  cart.checkout();

  // Assert
  expect(cart.getState()).toBe(CartState.CheckedOut);
});
```

```ts
// OK
it("should be Empty state when initialized", () => {
  // Act
  const cart = new Cart();

  // Assert
  expect(cart.getState()).toBe(CartState.Empty);
});
it("should be Active state after adding an item", () => {
  // Arrange
  const cart = new Cart();

  // Act
  cart.add(1000);

  // Assert
  expect(cart.getState()).toBe(CartState.Active);
});
it("should be CheckedOut state after checkout", () => {
  // Arrange
  const cart = new Cart();
  cart.add(1000);

  // Act
  cart.checkout();

  // Assert
  expect(cart.getState()).toBe(CartState.CheckedOut);
});
```

### テスト対象に合わせた深さ

ここの話は、単体ではなく複数のモジュールを結合した際の結合テストにも関わる話です。
テストは、そのプロダクトコードにある内容のテストが望ましいです。
多くのプロダクトコードは、責務によって関数やクラス、コンポーネントに分割されています。
それらを組み合わせて、1つの機能を実現します。

例えば、バリデーション用の関数と、それを使用した関数があるとします。

```ts
// バリデーション関数
export const isValidEmail = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

// それを使用した関数
export const sendEmail = (email: string): boolean => {
  if (!isValidEmail(email)) {
    throw new Error("Invalid email");
  }
  // メール送信処理
  return true;
};
```

この場合、`sendEmail` のテストコードを書く際に、`isValidEmail` の詳細なテストケースを書く必要はありません。
`isValidEmail` のテストコードは、別途用意します。

```ts
// sendEmail のテストコード
it("should send email when email is valid", () => {
  // Arrange
  const validEmail = "test@example.com";

// Act
  const result = sendEmail(validEmail);

// Assert
  expect(result).toBe(true);
});

it("should throw error when email is invalid", () => {
  // Arrange
  const invalidEmail = "invalid-email";

  // Act & Assert
  expect(() => sendEmail(invalidEmail)).toThrow("Invalid email");
});
```

```ts
// isValidEmail のテストコード
it.each`
  email                 | expected
  ${"test@example.com"} | ${true}
  ${"invalid-email"}    | ${false}
`("should return $expected for email: $email", ({ email, expected }) => {
  // Act
  const result = isValidEmail(email);
  // Assert
  expect(result).toBe(expected);
});
```

### 警告を無視しない

テストコードを書いていると、その実行ログに警告が出ることがあります。
これらの警告の内容によっては、テスト失敗する不安定なテスト（flaky test）になる可能性があります。
そのため、テスト実行時のログに警告が出ている場合は、できる限り潰すようにしましょう。

## 終わりに

TBD
